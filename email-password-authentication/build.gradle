import java.util.regex.Pattern;

plugins {
	id 'java-library'
	id 'com.github.node-gradle.node' version '3.6.0'
  id 'jacoco'
  id 'maven-publish'
  id("org.sonarqube") version "6.3.1.5724"
}

sonar {
  properties {
    property('sonar.projectName', 'SonarScanner for Krista Global Catalog (outlook-3.0 with Jacoco code coverage)')
    property("sonar.projectKey", "sonar-scanner-outlook-3.0")
    property("sonar.sources", "src/main/java")
    property("sonar.tests", "src/test/java")
    property("sonar.java.binaries", "build/classes/java/main")
    property("sonar.java.test.binaries", "build/classes/java/test")
    property("sonar.coverage.jacoco.xmlReportPaths", "build/reports/jacoco/test/jacocoTestReport.xml")
    property("sonar.junit.reportPaths", "build/test-results/test")
  }
}
tasks.test {
  // Generate coverage report after tests run
  finalizedBy(tasks.jacocoTestReport)
}
jacoco {
  toolVersion = "0.8.11"
}
tasks.jacocoTestReport {
  dependsOn(tasks.test)
  reports {
    xml.required = true   // Required for SonarQube
    html.required = true  // Useful for local viewing
    csv.required = false
  }
}
// Ensure Sonar runs only after JaCoCo report generation
tasks.named("sonar") {
  dependsOn(tasks.jacocoTestReport)
}

node {
  version = "18.17.1"
  npmVersion = "9.5.1"
  download = true
  nodeProjectDir = file("${project.projectDir}/ui")
}

tasks.register('buildReactApp', NpmTask) {
  dependsOn npmInstall
  inputs.dir("./ui")
  outputs.dir("./ui/dist")
  args = ['run', 'build']
}

group = 'com.krista.extensions.authentication.email_password_authentication'



java {
  sourceCompatibility = JavaVersion.VERSION_21
  targetCompatibility = JavaVersion.VERSION_21
}

compileJava {
  dependsOn clean
}

repositories {
  maven {
    url "https://packages.cicd.in.antbrains.com/artifactory/libs-release"
  }
  mavenCentral()
  mavenLocal()
}

dependencies {
  // External dependencies
  annotationProcessor 'app.krista:extension-impl-anno-processors:1.0.120'
  compileOnly 'app.krista:krista-apis:1.0.120'
  implementation 'org.glassfish.hk2:hk2-api:2.6.1'
  implementation 'org.apache.logging.log4j:log4j-slf4j2-impl:2.22.0'
  implementation group: 'javax.mail', name: 'javax.mail-api', version: '1.6.2'
  implementation group: 'com.sun.mail', name: 'javax.mail', version: '1.6.2'
}

tasks.register('copyReactApp', Copy) {
  doFirst {
    delete 'src/main/resources/ui' // Delete the existing UI directory
  }
  dependsOn buildReactApp
  from 'ui/dist'
  into 'src/main/resources/ui'
}

tasks.register('buildWithUI', GradleBuild) {
  buildFile = './build.gradle'
  tasks = ['copyReactApp', 'build']
}

/*
 * Use extension.name for archiveBaseName, extension.version for version.
 * Resulting jar: <extension.name>-<extension.version>.jar e.g. Demo Authentication-3.0.11.jar
 */
def computedBaseName = "Demo Authentication"
def computedVersion = "local"
tasks.register("setReleaseProperties") {
  dependsOn("generateReleaseProperties")
  doFirst {
    def releasePropsFile = file("release.properties")
    if (releasePropsFile.exists()) {
      def props = new Properties()
      releasePropsFile.withInputStream { stream -> props.load(stream) }
      computedBaseName = (props['extension.name'] ?: computedBaseName).replaceAll(/\s+/, "")
      computedVersion = props['extension.version'] ?: computedVersion
      project.ext.set("finalBaseName", computedBaseName)
      project.version = computedVersion
      println "✔ Loaded extension name = ${computedBaseName}, version = ${computedVersion}"
    } else {
      logger.warn("⚠ release.properties not found; using default values.")
      project.ext.set("finalBaseName", computedBaseName)
      project.version = computedVersion
    }
  }
}


abstract class GenerateReleasePropertiesTask extends DefaultTask {
  @TaskAction
  def generateProperties() {
    // Extension metadata (name, version) is defined on DemoAuthenticationExtension
    def extensionFilePath = 'src/main/java/com/krista/extensions/authentication/email_password_authentication/EmailPasswordAuthenticationExtension.java'
    // Domain/ecosystem metadata is taken from the catalog IntegrationArea
    def areaFilePath = 'src/main/java/com/krista/extensions/authentication/email_password_authentication/catalog/IntegrationArea.java'
    def extensionFile = project.file(extensionFilePath)
    def areaFile = project.file(areaFilePath)
    if (!extensionFile.exists()) {
      throw new GradleException("Extension file not found: ${extensionFilePath}")
    }
    if (!areaFile.exists()) {
      throw new GradleException("Area file not found: ${areaFilePath}")
    }
    def properties = new Properties()
    // Pre-compile the regex pattern for better performance
    def keyValuePattern = Pattern.compile(/(\w+)\s*=\s*"([^"]+)"/)
    // Extract Extension annotation information
    extractAnnotationInfo(extensionFile, "@Extension", keyValuePattern) { key, value ->
      if (key == "name") {
        properties.setProperty("extension.name", value)
        logger.lifecycle("Found extension name: ${value}")
      } else if (key == "version") {
        properties.setProperty("extension.version", value)
        logger.lifecycle("Found extension version: ${value}")
      }
    }
    // Extract Domain annotation information
    extractAnnotationInfo(areaFile, "@Domain", keyValuePattern) { key, value ->
      if (key == "name") {
        properties.setProperty("domain.name", value)
        logger.lifecycle("Found domain name: ${value}")
      } else if (key == "ecosystemName") {
        properties.setProperty("ecosystem.name", value)
        logger.lifecycle("Found ecosystem name: ${value}")
      }
    }
    if (!properties.getProperty('extension.version')) {
      throw new GradleException("Could not find extension version in ${extensionFilePath}")
    }
    if (!properties.getProperty('domain.name') || !properties.getProperty('ecosystem.name')) {
      throw new GradleException("Could not find domain name or ecosystem name in ${areaFilePath}")
    }
    def releasePropertiesFile = project.file('release.properties')
    def content = properties.collect { key, value -> "${key}=${value}" }.join('\n')
    releasePropertiesFile.text = content + '\n'
    logger.lifecycle("Generated release.properties with content:\n${content}")
  }
  /**
   * Extracts annotation information from a file
   * @param file The file to extract from
   * @param annotationName The annotation name to look for
   * @param keyValuePattern The regex pattern to extract key-value pairs
   * @param processProperty Closure to process each property
   */
  private static void extractAnnotationInfo(File file, String annotationName, Pattern keyValuePattern, Closure processProperty) {
    StringBuilder annotationText = new StringBuilder()
    boolean inAnnotation = false
    file.eachLine { line ->
      line = line.trim()
      if (line.contains(annotationName)) {
        inAnnotation = true
      }
      if (inAnnotation) {
        annotationText.append(line)
        if (line.contains(")")) {
          inAnnotation = false
          def matcher = keyValuePattern.matcher(annotationText.toString())
          while (matcher.find()) {
            def key = matcher.group(1)
            def value = matcher.group(2)
            processProperty.call(key, value)
          }
        }
      }
    }
  }
}
tasks.register('generateReleaseProperties', GenerateReleasePropertiesTask) {
  group = 'build'
  description = 'Generates release.properties file with extension version and domain information'
}
tasks.named("jar") {
  dependsOn tasks.named("generateReleaseProperties")
}
jar {
  // This task ensures that release.properties is read *after* it has been generated.
  // Gradle's configuration phase runs before tasks like `generateReleaseProperties` execute,
  // so directly reading the release.properties file earlier results in missing or default values.
  dependsOn tasks.named("setReleaseProperties")
  archiveBaseName = project.ext.has("finalBaseName") ? project.ext.finalBaseName : "Demo Authentication"
    archiveBaseName = "email-password-authentication"

    from {
      configurations.runtimeClasspath.collect {
        it.isDirectory() ? it : zipTree(it)
      }
    }

    exclude 'META-INF/*.RSA', 'META-INF/*.SF', 'META-INF/*.DSA'
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
  }

processResources {
  dependsOn copyReactApp
}